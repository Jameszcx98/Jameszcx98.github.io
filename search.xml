<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>redis</title>
      <link href="2021/06/04/redis/"/>
      <url>2021/06/04/redis/</url>
      
        <content type="html"><![CDATA[<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="为什么要用nosql"><a href="#为什么要用nosql" class="headerlink" title="为什么要用nosql"></a>为什么要用nosql</h2><blockquote><p>1.整个网站的瓶颈</p></blockquote><p>1.数据超过300万条就必须建立索引</p><p>2.访问量（读写混合），一个服务器承受不了</p><blockquote><p>2.memcached（缓存）+MySQL+垂直拆分</p><blockquote><p>发展过程：</p><p>1.优化数据结构和索引</p><p>2.文件缓存（IO）</p><p>3.Memcached（高速缓存）</p></blockquote></blockquote><p>1.网站80%的数据量都是在查询，所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率。（缓存只能解决读的问题）</p><blockquote><p>3.分库分表+水平拆分+MySQL集群</p></blockquote><p>我所认为的集群的概念是由数台服务器组成，都在完成一个功能，可看作成一个节点。</p><p>在第二阶段主要解决的是读的压力，第三个阶段主要是去解决写的压力。</p><blockquote><p>1.切换数据库引擎，由MyISAM-&gt;Innodb</p><p>MyISAM：表锁，效率低下</p><p>Innodb：行锁</p><p>2.使用分库分表技术</p><p>根据不同的业务</p><p>3.MySQL集群</p></blockquote><blockquote><p>4.如今最近的年代</p></blockquote><p>数据量大，且发生变化快。MySQL为代表的关系型数据库已经不能满足业务了（如定位信息，排行榜信息）数据库的IO压力下，表几乎没法变更大。</p><p>![image-20210522204209224](/Users/jameszhang/Library/Application Support/typora-user-images/image-20210522204209224.png)</p><center>当今互联网架构图</center><blockquote><p>为什么要用NoSQL！</p></blockquote><p>用户的个人信息，社交网络，地理位置，用户自己产生的数据，用户日志等等爆发式增长。nosql可以很好的处理这种情况。</p><h2 id="什么是NoSQL"><a href="#什么是NoSQL" class="headerlink" title="什么是NoSQL"></a>什么是NoSQL</h2><blockquote><p>Nosql</p></blockquote><p>Nosql=Not Only SQL（不仅仅是SQL）</p><p>关系型数据库：表格+行+列</p><p>泛指非关系型数据库，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区。</p><p>很多的数据类型用户的个人信息，社交网路，地理位置。这些数据的存储不需要一个固定的格式。redis就是通过类似于Java中的Map键值对来存储。</p><blockquote><p>Nosql特点</p></blockquote><p>解耦：</p><p>1.方便扩展（数据之间没有关系，很好扩展）</p><p>2.大数据量提高性能（Redis一秒写8万次，读取11万，Nosql的缓存记录是一种细粒度的缓存）</p><p>3.数据类型是多样型的（不需要事先设计数据库）</p><p>4.传统RDBMS和NoSQL</p><blockquote><p>传统的RDBMS</p><ul><li>结构化组织</li><li>SQL</li><li>数据和关系都存在单独的表中</li><li>数据操作语言，数据定义语言</li><li>严格的一致性</li><li>基础的事务</li></ul></blockquote><blockquote><p>Nosql</p><ul><li>不仅仅是数据库</li><li>没有固定的查询语言</li><li>键值对存储、列存储、文档存储、图型数据库</li><li>最终一致性</li><li>CAP定理和BASE（异地多活）</li><li>高并发、高可用、高可扩展（随时水平拆分）</li></ul></blockquote><p>大数据时代的3V+3高</p><p>大数据时代的3V：主要是描述问题的（海量、多样、实时）</p><p>大数据时代的3高：主要是对程序的要求</p><p>敏捷开发、极限编程</p><p>==去除差异化可以通过加一层来实现。==（比如连接多个版本数据库，业务模型的各个字段分布在不同数据源）添加了jdbc或者mybatis来连接数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#1.商品的基本信息</span>  名称、价格、商家信息；  在关系型数据库就可以解决 MySQL/Oracle（淘宝早年去IOE） 王坚<span class="token comment">#2.商品的描述，评论（文字比较多）</span>文档型数据库，MongDB<span class="token comment">#3.图片</span>分布式文件系统 FastDFS- 淘宝自己的 TFS- Google GFS- Hadoop HDFS- 阿里云的 oss<span class="token comment">#4.商品的关键字（搜索）</span>- 搜索引擎 Isearch 多隆<span class="token comment">#5.商品热门的波段信息</span>-内存数据库- Redis Tair<span class="token comment">#6.商品的交易，外部的支付接口</span>- 三方应用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>大型互联网应用信息：</p><ul><li>数据类型太多了</li><li>数据源繁多，经常重构</li><li>数据要改造，大面积改动</li></ul><p>==解决方案：统一数据服务平台（UDSL）==</p><h2 id="NoSQL的四大分类"><a href="#NoSQL的四大分类" class="headerlink" title="NoSQL的四大分类"></a>NoSQL的四大分类</h2><p><strong>kv键值对（内容缓存）：</strong></p><ul><li>新浪：<strong>Redis</strong></li><li>美团：Redis+Tair </li><li>阿里、百度：Redis+memecache</li></ul><p><strong>文档型数据库（bson格式和json一样）</strong></p><ul><li><strong>MongoDB</strong>：<ul><li>MongoDB是一个基于分布式文件存储系统的数据库，主要用于处理大量的文档</li><li>MongoDB是一个介于关系型数据库和非关系型数据库中中间的产品！MongoDB是非关系型数据库中功能最丰富，最像关系型数据库。</li></ul></li></ul><p><strong>列存储数据库</strong> </p><ul><li><strong>HBase</strong></li><li>分布式文件系统</li></ul><p><strong>图关系型数据库</strong></p><ul><li>他存放的是关系，应用场景比如：朋友圈社交网络，广告推荐！</li><li><strong>Neo4j</strong>，InfoGrid</li></ul><h2 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h2><blockquote><p>Redis是什么</p></blockquote><p>Redis（Remote Dictionary Server），即远程服务字典</p><p>支持网络、可基于内存和持久化的日志型，kv数据库</p><blockquote><p>Redis能干什么</p></blockquote><p>1.内存存储，持久化，因为内存中断电即失，所以持久化很重要（rdb，aof）</p><p>2.效率高，可以用于高速缓存</p><p>3.发布订阅系统</p><p>4.地图信息分析</p><p>5.计时器、计数器（浏览量）</p><blockquote><p>特性</p></blockquote><ol><li><p>多样的数据类型</p></li><li><p>持久化</p></li><li><p>集群</p></li><li><p>事务</p></li></ol><blockquote><p>学习中需要用到的东西</p></blockquote><ol><li>官网</li><li>中文网</li><li>下载地址</li></ol><p>（windows在Github上下载）</p><p>redis推荐是在Linux服务器上搭建的</p><h2 id="Redis下载安装"><a href="#Redis下载安装" class="headerlink" title="Redis下载安装"></a>Redis下载安装</h2><blockquote><ol><li>下载相关文件压缩包，并解压</li><li>下载运行环境（gcc）</li></ol><ul><li>```bash<br>yum install gcc-c++<pre class="line-numbers language-none"><code class="language-none">- make编译原文件 - make test 编译测试- make install编译安装1. 修改redis.conf 配置文件    * daemonize yes2. 启动redis-redis-server /.../ 配置文件的目录3. 访问redis-redis-cliRedis-benchmark是一个压力测试工具## 基础知识redis是一个基于内存存储的数据库系统，它可以用作数据库、缓存和消息中间件redis默认有16个数据库，默认使用的是第0个```bash#切换第几个数据库select x#查看数据库大小DBSIZE#查看所有的keykeys *#清空当前库flushdb#清空所有数据库flushall#是否存在键exists key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></blockquote><blockquote><p>redis是单线程</p></blockquote><p>redis是基于内存操作的，CPU利用率不是Redis的性能瓶颈，Redis的瓶颈是根据机器的内存和网络带宽，既然可以使用单线程来实现，就可以使用单线程了。</p><p>多线程还要涉及频繁的上下文切换</p><h2 id="redis基本类型"><a href="#redis基本类型" class="headerlink" title="redis基本类型"></a>redis基本类型</h2><p><strong>String类型</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#像一条记录后面添加字符串</span>append xxx <span class="token string">"xxx"</span><span class="token comment">#获取字符串长度</span>strlen xxx<span class="token comment">#实现++操作</span>incr xxxincrby xxx <span class="token number">10</span><span class="token comment">#实现--操作</span>decr xxxdecrby xxx <span class="token number">10</span><span class="token comment">#获得字符串某一区间的值(包括头尾)</span>getrange xxx <span class="token number">0</span> <span class="token number">3</span><span class="token comment">#修改某一字符串区间的值（offset为开始的下标）</span>setrange xxx offset xxx<span class="token comment">#setex(set with expire) 设置过期时间</span>setex xxx <span class="token number">30</span> <span class="token string">"ghjk"</span><span class="token comment">#setnx(set if not exist) 不存在再设置，在分布式锁中会常常使用</span><span class="token comment">#批量设置</span>mset k1 xxx k2 yyy k3 zzzmget k1 k2 k3msetnx<span class="token comment">#设置对象</span><span class="token builtin class-name">set</span> customer:1 <span class="token punctuation">{</span>name:james, age:9<span class="token punctuation">}</span>mset customer:2:name james customer:2:age <span class="token number">9</span><span class="token comment">#getset 先get后set</span>getset db redis<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>String的使用场景：可以是字符串还可以是数字</p><ul><li>计数器</li><li>统计多单位的数量 </li><li>粉丝数</li><li>对象缓存存储</li></ul><p><strong>List</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#向列表中添加值</span>LPUSH xxx oneRPUSH xxx twolset list 下标 xxx<span class="token comment">#从列表中获取在下标范围中的值</span>LRANGE list <span class="token number">0</span> -1<span class="token comment">#从列表中移除元素</span>Lpop list <span class="token comment">#移除list的第一个元素</span>Rpop list <span class="token comment">#移除list的最后一个</span>Lindex xxx <span class="token number">1</span> <span class="token comment">#通过下标获取list的值</span>Llen xxx <span class="token comment">#获取列表的长度</span>Lrem list （个数） xxx <span class="token comment">#从列表中移除制定的value及个数</span>ltrim list <span class="token number">1</span> <span class="token number">2</span> <span class="token comment">#通过下标的长度来截取列表长度</span>rpoplpush list1 list2 linsert list before <span class="token string">"world"</span> <span class="token string">"other"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Set</strong></p><p>set中的值是不重复的</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#set集合中添加值</span>sadd myset xxx<span class="token comment"># 查看指定set的所有值</span>smembers <span class="token builtin class-name">set</span><span class="token comment">#查看指定set的值是不是在集合中</span>sismember <span class="token builtin class-name">set</span> xxx<span class="token comment">#获取set集合中的内容元素的个数</span>scard <span class="token builtin class-name">set</span><span class="token comment">#移除set集合中的指定元素</span>srem <span class="token builtin class-name">set</span> xxx<span class="token comment">#随机获取number个元素</span>srandmember <span class="token builtin class-name">set</span> number<span class="token comment">#随机删除set集合中的元素</span>spop <span class="token builtin class-name">set</span><span class="token comment">#将一个集合中指定的值xxx移动到另一个集合</span>smove set1 set2 xxx<span class="token comment">#数字集合类（set1-set2）</span><span class="token function">sdiff</span> set1 set2 差集sinter set1 set2 交集sunion set1 set2 并集<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>粉丝共同关注</p><p><strong>Hash</strong></p><p>是一个集合，存储的value是键值对的方式,本质和string类型没有太大的区别</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#存取查</span>hset myhash xxx xxxhget myhash xxxhgetall myhashhmsethmgethdel myhash xxxhlen myhash <span class="token comment">#获取集合中的字段数量</span>hkeys myhashhvalues myhashhincrhdecrhexists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>hash用来存放变更的信息，尤其是用户信息的保存。hash更适合对象的存储，String更适合字符串的方式。</p><p><strong>Zset（有序集合）</strong></p><p>在set的基础上，添加一个值，add set xxx || zadd set score xxx</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#根据score进行排序</span>zrangebyscore zset -inf +inf withscoreszrange salary <span class="token number">0</span> -1zrerange salary <span class="token number">0</span> -1 <span class="token comment">#移除任务中的元素</span>zrem zset xxx<span class="token comment">#获取集合中的个数</span>zcard salary<span class="token comment">#获取集合范围为n1到n2的个数</span>zcount salary n1 n2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>案例思路：</p><p>对set集合进行排序，还可以存储班级成绩，工资表排序，</p><p>对代权重的值进行判断，如普通消息为1，重要消息为2</p><p>排行榜应用场景</p><h2 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h2><p><strong>geospatial 地理位置</strong></p><p>应用场景：</p><p>朋友的定位、附近的人、打车距离计算</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#添加地理位置 geoadd （集合） 经度 纬度 城市名</span>geoadd china:city <span class="token number">116.40</span> <span class="token number">39.90</span> beijinggeoadd china:city <span class="token number">116.40</span> <span class="token number">39.90</span> chongqing<span class="token comment"># 返回两个给定位置之间的距离</span><span class="token comment">#单位如下：m、km、mi（英里）、ft（英尺）</span>geodist china:city beijing chongqing km<span class="token comment">#命令返回11个字符的geohash字符串,将二维的经纬度转换为一维的字符串，如果连个字符串越像位置越接近</span>geohash china:city beijing chongqing<span class="token comment">#从key里返回所有给定元素的位置</span>geopos china:city beijing chongqing<span class="token comment">#以给定的经纬度为中心，找出某一半径内的元素</span>georadius china:city <span class="token number">100</span> <span class="token number">30</span> 1000km withdist withcoord count number<span class="token comment">#用于找出位于指定范围内的元素，中心点是由给定的位置元素决定</span>georadiusbymember china:city beijing 1000km<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>基于zset封装，可以用zrem删除</p><p><strong>Hyperloglog</strong></p><blockquote><p>用于基数统计的算法</p><p>基数，是集合中不重复数字的数量</p></blockquote><p><strong>应用场景：网页的uv（一个人访问多次还是算作一个人）</strong></p><p>传统的方式，set保存用户的ID，然后就可以统计set中的元素数量作为标准的判断。这个方式如果保存大量的用户ID，与我们的意愿相违背。</p><p>优点：占用的内存是固定的，2^ 64不同的元素技术，只需要12kb。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">PFadd mykey a b c d e f g h i jPFcount mykey PFmerge mykey mykey1 mykey2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果可以容错，可以使用hperloglog，有0.81%的错误率</p><p><strong>bitmaps</strong></p><p>位存储</p><p>统计疫情感染人数</p><p>统计用户信息，活跃与不活跃 登陆与未登录 只有两个状态的都可以使用bitmaps</p><p>bitmaps位图，都是操作二进制位来进行记录，只有0和1两个状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#使用bitmap来记录周一到周日的打卡</span>setbit sign <span class="token number">0</span> <span class="token number">1</span>setbit sign <span class="token number">1</span> <span class="token number">1</span>setbit sign <span class="token number">2</span> <span class="token number">1</span>setbit sign <span class="token number">3</span> <span class="token number">1</span>setbit sign <span class="token number">4</span> <span class="token number">1</span><span class="token comment">#查看某一天是否有打卡</span>getbit sign <span class="token number">0</span>getbit sign <span class="token number">1</span><span class="token comment">#统计打卡的天数(1)</span>bitcount sign<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>==Redis单条命令是保证原子性的，但是事务是不保证原子性、隔离性的。==</p><p>Redis事务本质：一组命令的集合。一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序执行，具有一次性、顺序性、排他性。</p><p>所有的命令在事务中，并没有直接被执行，只有发起执行命令的时候才会被执行。</p><p>Redis的事务：</p><ul><li>开启事务（multi）</li><li>命令入队（。。。）</li><li>执行命令（exec）</li></ul><p>锁：Redis可以实现乐观锁</p><blockquote><p>正常执行事务</p></blockquote><p>![image-20210603193209476](/Users/jameszhang/Library/Application Support/typora-user-images/image-20210603193209476.png)</p><blockquote><p>放弃事务</p></blockquote><p>![image-20210603193530871](/Users/jameszhang/Library/Application Support/typora-user-images/image-20210603193530871.png)</p><blockquote><p>编译型异常（代码有问题！命令有错），事务中所有的命令都不会被执行</p></blockquote><p>![image-20210603194435757](/Users/jameszhang/Library/Application Support/typora-user-images/image-20210603194435757.png)</p><blockquote><p>运行时异常，如果事务队列中存在语法性，那么执行命令的时候，其他命令可以正常执行的。</p></blockquote><p>![image-20210603194548018](/Users/jameszhang/Library/Application Support/typora-user-images/image-20210603194548018.png)</p><blockquote><p>监控watch：</p></blockquote><p><strong>悲观锁：</strong></p><ul><li>很悲观，认为数据会发生并发问题，所以无论做什么都会加锁</li></ul><p><strong>乐观锁：</strong></p><ul><li>很乐观，认为什么时候不会出错，所以不会上锁。在更新数据的时候会去判断一下，在此期间是否有人修改过这个数据。</li><li>获取version</li><li>更新的时候比较version</li></ul><blockquote><p>Redis测监视测试：</p></blockquote><p>![image-20210603200019697](/Users/jameszhang/Library/Application Support/typora-user-images/image-20210603200019697.png)</p><p>在执行事务的时候，其他线程对money字段进行了修改，由于监视了money字段，导致事务执行失败，保证了数据的正确性。之后先unwatch解锁，在watch加锁。</p><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><blockquote><p>Jedis是Redis官方推荐的Java连接工具，使用Java操作Redis的中间件。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 后端笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello-World</title>
      <link href="2021/06/01/hello-world/"/>
      <url>2021/06/01/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello-Hexo"><a href="#Hello-Hexo" class="headerlink" title="Hello Hexo"></a>Hello Hexo</h1><p>这是我第一次使用Hexo来记录我的生活。众所周知，程序员通常使用hello world来宣告自己成功运用了一门新技术。所以今天我特意用Hello Hexo一文来传承这种仪式感，有一句古话“靡不有初，鲜克有终“，搭建一个Blog很容易，但坚持下去并非易事，所以真心希望自己可以把James’s Blog做出一番名堂。</p><p>说起为什么将网站起名为James’s Blog。其实还挺显而易见的，因为我从小就喜欢LeBron James，所以顺势将James作为了我的英文名。今天恰是湖人队的季后赛首轮生死战，可惜LeBron失败了，生涯首次首轮季后赛出局。然而细想起来也不足为奇，今年LeBron37岁了。哎真的是时光如梭啊，LeBron最引以为豪的记录之一就是10次进入总决赛其中有8年连续打进。这10次也基本涵盖了我有生之年所有的重大节点，小升初、中考、高考、考研。而今年的失利，英雄迟暮的感觉涌上心头。上次这种感觉还是KoBe的退役。</p><p>而此时此刻，我也即将开启我的职业生涯，其实计算机人虽然不是靠身体吃饭，但是职业生涯的代码黄金时间也是寥寥无几。新闻中35岁程序员失业的新闻还是蛮多的，为了避免英雄迟暮的中年危机，我觉得要利用起现在每分每秒，只有青春不虚度，才能有更多的人生经验，才能老而弥坚变成骚气的中年男性。</p><p>最后借用我爸的话，要“抬头看路也要低头拉车”，虽然细想跟“仰望星空脚踏实地”表达的意思上没啥区别。但是我还是更喜欢我爸说的，低头拉车比脚踏实地功能体现出为生活所做出的拼搏。所以在拉车的时候请低下头，努力吧少年！</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
